#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "git/whence" => "require \"git/whence/version\"\nrequire \"optparse\"\n\nmodule Git::Whence\n  module CLI\n    class << self\n      def run(argv)\n        options = parse_options(argv)\n        commit = argv[0]\n        unless system(\"git rev-parse --git-dir 2>&1 >/dev/null\")\n          puts \"Not in a git directory\"\n          return 1\n        end\n\n        commit = expand(commit)\n\n        if is_merge?(commit)\n          $stderr.puts \"Commit is a merge\"\n          finished_with_commit(commit, options)\n          1\n        else\n          merge = find_merge(commit)\n          if merge\n            finished_with_commit(merge, options)\n            0\n          else\n            $stderr.puts \"Unable to find merge\"\n            1\n          end\n        end\n      end\n\n      private\n\n      def expand(commit)\n        sh(\"git show \#{commit} -s --format='%H'\").strip\n      end\n\n      def is_merge?(commit)\n        sh(\"git cat-file -p \#{commit}\").split(\"\\n\")[1..2].grep(/parent /).size > 1\n      end\n\n      def finished_with_commit(merge, options)\n        info = sh(\"git show -s --oneline \#{merge}\").strip\n        if options[:open] && (pr = info[/Merge pull request #(\\d+) from /, 1]) && (url = origin)\n          repo = url[%r{(\\w+/[-\\w\\.]+)}i, 1].to_s.sub(/\\.git$/, \"\")\n          exec %Q{open \"https://github.com/\#{repo}/pull/\#{pr}\"}\n        else\n          puts info\n        end\n      end\n\n      def origin\n        remotes = sh(\"git remote -v\").split(\"\\n\")\n        remotes.detect { |l| l.start_with?(\"origin\\t\") }.split(\" \")[1]\n      end\n\n      def find_merge(commit)\n        commit, merge = find_merge_simple(commit, \"HEAD\") ||\n          find_merge_simple(commit, \"master\") ||\n          find_merge_fuzzy(commit, \"master\")\n\n        merge if merge && merge_include_commit?(merge, commit)\n      end\n\n      def merge_include_commit?(merge, commit)\n        commit = sh(\"git show HEAD -s --format=%H\").strip if commit == \"HEAD\"\n        sh(\"git log \#{merge.strip}^..\#{merge.strip} --pretty=%H\").split(\"\\n\").include?(commit)\n      end\n\n      def find_merge_fuzzy(commit, branch)\n        if similar = find_similar(commit, branch)\n          find_merge_simple(similar, branch)\n        end\n      end\n\n      def find_similar(commit, branch)\n        month = 30 * 24 * 60 * 60\n        time, search = sh(\"git show -s --format='%ct %an %s' \#{commit}\").strip.split(\" \", 2)\n        time = time.to_i\n        same = sh(\"git log \#{branch} --pretty=format:'%H %an %s' --before \#{time + month} --after \#{time - month}\")\n        found = same.split(\"\\n\").map { |x| x.split(\" \", 2) }.detect { |commit, message| message == search }\n        found && found.first\n      end\n\n      def find_merge_simple(commit, branch)\n        result = sh \"git log \#{commit}..\#{branch} --ancestry-path --merges --pretty='%H' 2>/dev/null | tail -n 1\"\n        [commit, result] unless result.strip.empty?\n      end\n\n      def sh(command)\n        result = `\#{command}`\n        raise unless $?.success?\n        result\n      end\n\n      def parse_options(argv)\n        options = {}\n        OptionParser.new do |opts|\n          opts.banner = <<-BANNER.gsub(/^ {10}/, \"\")\n            Find the merge and pull request a commit came from, also finding straight cherry-picks.\n\n            Usage:\n                git-whence <sha>\n\n            Options:\n          BANNER\n          opts.on(\"-o\", \"--open\", \"Open PR in github\") { options[:open] = true }\n          opts.on(\"-h\", \"--help\", \"Show this.\") { puts opts; exit }\n          opts.on(\"-v\", \"--version\", \"Show Version\"){ puts Git::Whence::VERSION; exit}\n        end.parse!(argv)\n\n        raise \"just 1 commit plz\" if argv.size != 1\n\n        options\n      end\n    end\n  end\nend\n",
    "git/whence/version" => "module Git\n  module Whence\n    VERSION = \"0.1.3\"\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path("../../lib", __FILE__)
require "rubygems" if RUBY_VERSION < "1.9"
require "git/whence"
exit Git::Whence::CLI.run(ARGV)
