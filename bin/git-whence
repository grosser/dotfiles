#!/usr/bin/env ruby
# generated by rubinjam v0.7.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "git/whence" => "require \"git/whence/version\"\nrequire \"optparse\"\n\nmodule Git::Whence\n  module CLI\n    SQUASH_REGEX = /\\(#(\\d+)\\)$/\n\n    class << self\n      def run(argv)\n        options = parse_options(argv)\n        commit = argv[0]\n        unless system(\"git rev-parse --git-dir 2>&1 >/dev/null\")\n          warn \"Not in a git directory\"\n          return 1\n        end\n\n        commit = expand(commit)\n\n        if is_merge?(commit)\n          warn \"Commit is a merge\"\n          show_commit(commit, options)\n          1\n        else\n          if merge = find_merge(commit)\n            show_commit(merge, options)\n            0\n          else\n            warn \"Unable to find merge\"\n            show_commit(commit, options) if options[:open]\n            1\n          end\n        end\n      end\n\n      private\n\n      def expand(commit)\n        sh(\"git rev-parse \#{commit}\").strip\n      end\n\n      def is_merge?(commit)\n        sh(\"git cat-file -p \#{commit}\").split(\"\\n\")[1..2].grep(/parent /).size > 1\n      end\n\n      def show_commit(merge, options)\n        info = sh(\"git show -s --oneline \#{merge}\").strip\n        if options[:open]\n          if pr = info[/Merge pull request #(\\d+) from /, 1] || info[SQUASH_REGEX, 1]\n            exec \"open\", \"https://github.com/\#{origin}/pull/\#{pr}\"\n          else\n            warn \"Unable to find PR number in \#{info}\"\n            exec \"open\", \"https://github.com/\#{origin}/commit/\#{merge}\"\n          end\n        else\n          puts info\n        end\n      end\n\n      # https://github.com/foo/bar or git@github.com:foo/bar.git -> foo/bar\n      def origin\n        repo = sh(\"git remote get-url origin\").strip # TODO: read file instead\n        repo.sub!(/\\.git$/, \"\")\n        repo.split(/[:\\/]/).last(2).join(\"/\")\n      end\n\n      def find_merge(commit)\n        merge_commit, merge = (\n          find_merge_simple(commit, \"HEAD\") ||\n          find_merge_simple(commit, \"master\") ||\n          find_merge_fuzzy(commit, \"master\")\n        )\n\n        if merge && merge_include_commit?(merge, merge_commit)\n          merge\n        else\n          find_squash_merge(commit) # not very exact, so do this last ... ideally ask github api\n        end\n      end\n\n      def merge_include_commit?(merge, commit)\n        commit = sh(\"git show HEAD -s --format=%H\").strip if commit == \"HEAD\"\n        sh(\"git log \#{merge.strip}^..\#{merge.strip} --pretty=%H\").split(\"\\n\").include?(commit)\n      end\n\n      def find_merge_fuzzy(commit, branch)\n        if similar = find_similar(commit, branch)\n          find_merge_simple(similar, branch)\n        end\n      end\n\n      def find_squash_merge(commit)\n        commit if sh(\"git show -s --format='%s' \#{commit}\") =~ SQUASH_REGEX\n      end\n\n      def find_similar(commit, branch)\n        month = 30 * 24 * 60 * 60\n        time, search = sh(\"git show -s --format='%ct %an %s' \#{commit}\").strip.split(\" \", 2)\n        time = time.to_i\n        same = sh(\"git log \#{branch} --pretty=format:'%H %an %s' --before \#{time + month} --after \#{time - month}\")\n        found = same.split(\"\\n\").map { |x| x.split(\" \", 2) }.detect { |_, message| message == search }\n        found && found.first\n      end\n\n      def find_merge_simple(commit, branch)\n        result = sh(\"git log \#{commit}..\#{branch} --ancestry-path --merges --pretty='%H' 2>/dev/null | tail -n 1\").chomp\n        [commit, result] unless result.empty?\n      end\n\n      def sh(command)\n        result = `\#{command}`\n        raise \"Command failed\\n\#{command}\\n\#{result}\" unless $?.success?\n        result\n      end\n\n      def parse_options(argv)\n        options = {}\n        OptionParser.new do |opts|\n          opts.banner = <<-BANNER.gsub(/^ {10}/, \"\")\n            Find the merge and pull request a commit came from, also finding straight cherry-picks.\n\n            Usage:\n                git-whence <sha>\n\n            Options:\n          BANNER\n          opts.on(\"-o\", \"--open\", \"Open PR in github\") { options[:open] = true }\n          opts.on(\"-h\", \"--help\", \"Show this.\") { puts opts; exit }\n          opts.on(\"-v\", \"--version\", \"Show Version\"){ puts Git::Whence::VERSION; exit}\n        end.parse!(argv)\n\n        raise \"just 1 commit plz\" if argv.size != 1\n\n        options\n      end\n    end\n  end\nend\n",
    "git/whence/version" => "module Git\n  module Whence\n    VERSION = \"0.3.0\"\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path("../../lib", __FILE__)
require "rubygems" if RUBY_VERSION < "1.9"
require "git/whence"
exit Git::Whence::CLI.run(ARGV)
