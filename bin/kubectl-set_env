#!/usr/bin/env ruby
# set environment variables on the first container of kubernetes resources
# kubectl set-env deploy my-app -n foo KEY=value
# kubectl set-env deploy my-app -n foo KEY=-
#
# TODO: support setting -c for which container/initContainer to set env vars on

require 'json'
require 'shellwords'

DELETE_MARKER = "-"

# build patches to use with kubectl patch
# TODO: no patch when there is no change
def container_env_patches(container, new_vars)
  path = "/spec/template/spec/containers/0/env"
  existing_env = container["env"] || []
  new_vars.filter_map do |k, v|
    if (index = existing_env.index { |e| e["name"] == k })
      next if existing_env[index]["value"] == v # noop
      if v == DELETE_MARKER
        { "op" => "remove", "path" => "#{path}/#{index}"}
      else # update existing value or replace valueFrom
        { "op" => "replace", "path" => "#{path}/#{index}", "value" => { "name" => k, "value" => v} }
      end
    elsif v != DELETE_MARKER
      { "op" => "add", "path" => "#{path}/-", "value" => { "name" => k, "value" => v } }
    end
  end
end

# split arguments into env vars and others
env, argv = ARGV.partition { |arg| arg.match?(/[A-Z\d_]+=/) }
env = env.to_h { |arg| arg.split('=', 2) }
abort "No environment variables specified. Use KEY=value format." if env.empty?

# get current resource
data = `kubectl get #{argv.shelljoin} -o json`
abort "kubectl get failed" unless $?.success?
resource = JSON.parse(data)
raise "multiple resources not supported yet" if resource["items"]

# build patches
pod_template = resource.dig("spec", "template") || resource
container = pod_template.dig("spec", "containers", 0) || raise("No containers found in resource")
patches = container_env_patches container, env
if patches.empty?
  warn "No changes needed"
  exit 0
end

# apply
`kubectl patch #{argv.shelljoin} --type json -p #{patches.to_json.shellescape}`
abort "kubectl patch failed" unless $?.success?
