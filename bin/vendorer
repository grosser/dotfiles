#!/usr/bin/env ruby
# generated by rubinjam v0.6.0 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "vendorer" => "require 'tempfile'\nrequire 'tmpdir'\nrequire 'shellwords'\n\nclass Vendorer\n  def initialize(options={})\n    @options = options\n    @sub_path = []\n  end\n\n  def parse(content)\n    eval(content, nil, 'Vendorfile', 1)\n  end\n\n  def file(path, url=nil)\n    target_path = complete_path(path)\n    update_or_not target_path do\n      run \"mkdir\", \"-p\", File.dirname(target_path)\n      if @copy_from_url\n        copy_from_path(target_path, url || path)\n      else\n        run \"curl\", url, \"--fail\", \"-L\", \"--compressed\", \"-o\", target_path\n        raise \"Downloaded empty file\" unless File.exist?(target_path)\n      end\n      yield target_path if block_given?\n    end\n  end\n\n  def folder(path, url=nil, options={})\n    if @copy_from_path or url\n      target_path = complete_path(path)\n      update_or_not target_path do\n        run \"rm\", \"-rf\", target_path\n        run \"mkdir\", \"-p\", File.dirname(target_path)\n        if @copy_from_path\n          copy_from_path(target_path, url || path)\n        else\n          download_repository(url, target_path, options)\n        end\n        yield target_path if block_given?\n      end\n    else\n      @sub_path << path\n      yield\n      @sub_path.pop\n    end\n  end\n\n  def rewrite(path)\n    content = File.read(path)\n    result = yield content\n    File.open(path,'w'){|f| f.write(result) }\n  end\n\n  # Creates Vendorfile with examples\n  def init\n    separator = \"<!-- extracted by vendorer init -->\"\n    readme = File.read(File.expand_path('../../Readme.md', __FILE__))\n    examples = readme.split(separator)[1]\n    examples.gsub!(/```.*/,'') # remove ``` from readme\n    examples = examples.split(\"\\n\").map do |l|\n      (l.start_with? '#' or l.empty?) ? l : \"# \#{l}\"\n    end.join(\"\\n\")\n    File.open('Vendorfile', 'w') { |f| f.write(examples.strip) }\n  end\n\n  def from(url, options={})\n    Dir.mktmpdir do |tmpdir|\n      download_repository url, tmpdir, options\n      @copy_from_url, @copy_from_path = url, tmpdir\n      yield(@copy_from_path)\n      @copy_from_url = @copy_from_path = nil\n    end\n  end\n\n  private\n\n  def update_or_not(path)\n    update_requested = (@options[:update] and (@options[:update] == true or path.start_with?(@options[:update]+'/') or path == @options[:update]))\n    if update_requested or not File.exist?(path)\n      puts \"updating \#{path}\"\n      yield\n    else\n      puts \"keeping \#{path}\"\n    end\n  end\n\n  def run(*cmd, dir: nil)\n    cmd = \"\#{cmd.shelljoin} 2>&1\"\n    cmd = [\"cd\", dir].shelljoin + \" && \#{cmd}\" if dir\n    output = `\#{cmd}`\n    raise \"Failed: \#{cmd}\\n\#{output}\" unless $?.success?\n  end\n\n  def complete_path(path)\n    File.join(@sub_path + [path])\n  end\n\n  def download_repository(url, to, options)\n    run \"git\", \"clone\", url, to\n    if commit = (options[:ref] || options[:tag] || options[:branch])\n      run \"git\", \"checkout\", commit, dir: to\n    end\n    run \"git\", \"submodule\", \"update\", \"--init\", \"--recursive\", dir: to\n    run \"rm\", \"-rf\", \".git\", dir: to\n  end\n\n  def copy_from_path(dest_path, src_path)\n    src_path ||= dest_path\n    copy_from = File.join(@copy_from_path, src_path)\n    raise \"'\#{src_path}' not found in \#{@copy_from_url}\" unless File.exist?(copy_from)\n    run \"cp\", \"-Rp\", copy_from, dest_path\n  end\nend\n",
    "vendorer/version" => "class Vendorer\n  VERSION = '0.2.0'\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
# encoding: UTF-8
require 'optparse'
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

options = {}
parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
Vendorer keeps your vendor files up to date.

Usage:

Create a Vendorfile in your project root with:

    file 'public/javascripts/jquery.min.js' => 'http://code.jquery.com/jquery-latest.min.js'
    folder 'vendor/plugins/parallel_tests' => 'https://github.com/grosser/parallel_tests.git'

Run `vendorer init` to create Vendorfile.
Run `vendorer` to install.
Run `vendorer update` to update.

Options:
BANNER
  opts.on("-v", "--version", "Show Version"){
    require 'vendorer/version'
    puts Vendorer::VERSION
    exit
  }
  opts.on("-h", "--help", "Show this.") { puts opts; exit }
end
parser.parse!

require 'vendorer'
v = Vendorer.new(:update => (ARGV[1] || true if ARGV[0] == 'update'),
                 :init   => (true if ARGV[0] == 'init'))
v.init and exit if ARGV[0] == 'init'
config_locations = ['Vendorfile.rb', 'Vendorfile']
config_location = config_locations.detect { |f| File.exist?(f) } || config_locations.last
v.parse(File.read(config_location))
