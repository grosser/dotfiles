#!/usr/bin/env ruby
# updates the .golangci.yaml importas section with all used aliases

# TODO: should ignore lines ignored by govet
# TODO: should not ignore unaliases packages with the same name foo/client vs bar/client
# TODO: for regex matchers also verify that all combinations are unique

require "yaml"

file_path = ".golangci.yml"
alias_path = ["linters-settings", "importas", "alias"]
spacer = "  " * alias_path.size
placeholder = "#{spacer}# GENERATED BY golangci-importas-refresh do not modify manually\n"

# find all used aliases
found_aliases = Dir["{cmd,pkg,test}/**/*.go"].flat_map do |file|
  imports = File.read(file)[/^import \(\n(.*?)\)/m, 1].to_s.split("\n")
  imports.filter_map do |import|
    next unless import =~ /^\s+(\S+)\s+"(\S+\/\S+)"$/ # only non-core packages have aliases enforced by importas
    next if $1 == "." # ignore inlined
    next if $1 == "_" # ignore imported for cli tooling
    {"pkg" => $2, "alias" => $1}
  end
end

# read the current list
current_aliases = YAML.load_file(file_path).dig(*alias_path) || []

# make the current one or the most used one the default
new_aliases = found_aliases
  .sort_by { |a| a["pkg"] }
  .group_by { |a| a["pkg"] }
  .map do |pkg, fas|
    current_aliases.detect { |ca| ca["pkg"] == pkg || Regexp.new(ca["pkg"]).match?(pkg) } ||
      fas.group_by { |a| a["alias"] }.sort_by { |_, as| -as.size }[0][1][0]
  end
  .uniq # when using regex matching we will find multiple that match the same current alias

# verify no alias duplication, but ignore regex resolved ones
# this is also enforced by "importas", but not for regexes
dupes = new_aliases
  .reject { |a| a["alias"].include?("$") }
  .group_by { |a| a["alias"] }.select { |_, nas| nas.size > 1 }
if dupes.any?
  message = "These aliases have dupes, make them unique before continuing:"
  message += "\n"
  dupes.each { |a, ds| message += "  #{a}:\n#{ds.map { |d| "    #{d["pkg"]}" }.join("\n")}\n" }
  abort message
end

# write the new config file
new_content = new_aliases.to_yaml.sub(/^---\n/, '').gsub(/^/, spacer)
if (parts = File.read(file_path).split(placeholder, -1)) && parts.size == 3
  parts[1] = new_content
  File.write(file_path, parts.join(placeholder))
else
  puts "Place this chunk in #{alias_path.join(": ")}"
  puts "#{placeholder}#{new_content}#{placeholder}"
end
