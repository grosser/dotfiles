#!/usr/bin/env ruby
# generated by rubinjam v0.7.0 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "git/autobisect/version" => "module Git\n  module Autobisect\n    VERSION = Version = \"0.4.2\"\n  end\nend\n",
    "git/autobisect" => "require \"git/autobisect/version\"\n\nmodule Git\n  module Autobisect\n    class << self\n      def cli(argv)\n        options = extract_options(argv)\n\n        command = argv.first\n        if command.to_s.empty?\n          puts \"Usage instructions: git-autobisect --help\"\n          return 1\n        end\n\n        # make sure bundle is fresh before each run\n        if !options[:no_bundle] && File.exist?(\"Gemfile\")\n          command = \"(bundle check || (test -f vendor/cache && bundle --local --quiet) || bundle --quiet) && (\#{command})\"\n        end\n\n        # reset changes but keep the exit status\n        command += \"; export X=$? ; git reset --hard ; exit $X\"\n\n        run_command(command, options) || 0\n      end\n\n      def run_command(command, options)\n        commits = `git log --pretty=format:'%h' | head -n \#{options[:max]}`.split(\"\\n\")\n        good, bad = find_good_and_bad_commit(commits, command, options)\n\n        if good == commits.first\n          puts \" ---> HEAD is not broken\"\n          return 1\n        elsif not good\n          puts \" ---> No good commit found before HEAD~\#{options[:max]}\"\n          return 1\n        end\n\n        if exact_commit_known?(commits, good, bad)\n          # return same result as git bisect\n          run! \"git checkout \#{bad}\"\n          puts \"\#{bad} is the first bad commit\"\n          puts `git show \#{bad}`\n        else\n          first_bad = bisect_to_exact_match(command, good, bad)\n          run! \"git checkout \#{first_bad}\"\n        end\n      end\n\n      private\n\n      def extract_options(argv)\n        options = {\n          :max => 1000\n        }\n        OptionParser.new do |opts|\n          opts.banner = <<-BANNER.gsub(\" \"*12, \"\")\n            Find the commit that broke the build\n\n            Usage:\n                git-autobisect 'ruby test/foo_test.rb -n \"/xxx/\"' [options]\n\n            Options:\n          BANNER\n          opts.on(\"-h\", \"--help\", \"Show this.\") { puts opts; exit }\n          opts.on(\"-v\", \"--version\", \"Show Version\"){ puts \"git-autobisect \#{Version}\"; exit }\n          opts.on(\"-m\", \"--max N\", Integer, \"Inspect commits between HEAD..HEAD~<max>\"){|max| options[:max] = max }\n          opts.on(\"-s\", \"--start N\", Integer, \"Use N (instead of 1) as initial step and keep multiplying by 2\"){|start| options[:start] = start }\n          opts.on(\"--step N\", Integer, \"Use N as step (instead of multiplying by 2)\"){|step| options[:step] = step }\n          opts.on(\"--no-bundle\", \"Do not bundle even if a Gemfile exists\"){ options[:no_bundle] = true }\n        end.parse!(argv)\n        options\n      end\n\n      def run(cmd)\n        all = \"\"\n        puts cmd\n        IO.popen(cmd) do |pipe|\n          while str = pipe.gets\n            all << str\n            puts str\n          end\n        end\n        [$?.success?, all]\n      end\n\n      def run!(command)\n        raise \"Command failed \#{command}\" unless run(command).first\n      end\n\n      def find_good_and_bad_commit(commits, command, options)\n        initial = 1\n        i = options[:start] || initial\n        step = options[:step]\n        maybe_good = commits.first\n\n        loop do\n          # scan backwards through commits to find a good\n          offset = [i - 1, commits.size-1].min\n          maybe_good, bad = commits[offset], maybe_good\n          return if i > initial and bad == maybe_good # we reached the end\n\n          # see if it works\n          puts \" ---> Now trying \#{maybe_good} (HEAD~\#{offset})\"\n          run!(\"git checkout \#{maybe_good}\")\n          return [maybe_good, bad] if run(command).first\n          step ? i += step : i *= 2\n        end\n      end\n\n      def bisect_to_exact_match(command, good, bad)\n        run! \"git bisect reset\"\n        run! \"git bisect start \#{bad} \#{good}\"\n        success, output = run(\"git bisect run sh -c '\#{command}'\")\n        raise \"error while bisecting\" unless success\n        output.match(/([\\da-f]+) is the first bad commit/)[1]\n      end\n\n      def exact_commit_known?(commits, good, bad)\n        (commits.index(good) - commits.index(bad)).abs <= 1\n      end\n    end\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#! /usr/bin/env ruby
require 'optparse'
$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'git/autobisect'
exit Git::Autobisect.cli(ARGV)
